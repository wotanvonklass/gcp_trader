use serde::{Deserialize, Serialize};
use std::fmt;
use uuid::Uuid;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum Cluster {
    Stocks,
}

impl Cluster {
    pub fn url(&self, config: &crate::config::Config) -> String {
        match self {
            Self::Stocks => config.firehose_url.clone(),
        }
    }

    pub fn port(&self, config: &crate::config::Config) -> u16 {
        match self {
            Self::Stocks => config.stocks_port,
        }
    }
}

impl fmt::Display for Cluster {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Stocks => write!(f, "stocks"),
        }
    }
}

// Client message types
#[derive(Debug, Deserialize, Serialize)]
#[serde(tag = "action")]
pub enum ClientMessage {
    #[serde(rename = "auth")]
    Auth { params: String },
    #[serde(rename = "subscribe")]
    Subscribe { params: String },
    #[serde(rename = "unsubscribe")]
    Unsubscribe { params: String },
}

// Status messages
#[derive(Debug, Serialize)]
pub struct StatusMessage {
    pub status: String,
    pub message: String,
}

// Simple message for routing (we need symbol and event type)
#[derive(Debug, Deserialize)]
pub struct DataMessage {
    pub sym: Option<String>,  // Symbol field for trades/quotes
    pub ev: String,           // Event type (T, Q, A, AM, LULD, FMV, etc.)
}

pub type ClientId = Uuid;

// Utility to check if a subscription is for bar data
pub fn is_bar_subscription(symbol: &str) -> bool {
    // Bar subscriptions:
    // - A.* (second bars from Polygon)
    // - AM.* (minute bars from Polygon)
    // - *Ms.* (millisecond bars generated by ms-aggregator)
    symbol.starts_with("A.") || symbol.starts_with("AM.") || symbol.contains("Ms.")
}

// Check if a subscription is for millisecond bars specifically (generated by ms-aggregator)
pub fn is_ms_bar_subscription(symbol: &str) -> bool {
    // Only millisecond bars: 100Ms.*, 250Ms.*, 500Ms.*, etc.
    // NOT A.* or AM.* (those are native Polygon bars)
    symbol.contains("Ms.")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_is_bar_subscription_second_bars() {
        assert!(is_bar_subscription("A.AAPL"));
        assert!(is_bar_subscription("A.TSLA"));
        assert!(is_bar_subscription("A.*"));
    }

    #[test]
    fn test_is_bar_subscription_minute_bars() {
        assert!(is_bar_subscription("AM.AAPL"));
        assert!(is_bar_subscription("AM.TSLA"));
        assert!(is_bar_subscription("AM.*"));
    }

    #[test]
    fn test_is_bar_subscription_millisecond_bars() {
        assert!(is_bar_subscription("100Ms.AAPL"));
        assert!(is_bar_subscription("250Ms.TSLA"));
        assert!(is_bar_subscription("500Ms.SPY"));
        assert!(is_bar_subscription("1000Ms.NVDA"));
    }

    #[test]
    fn test_is_bar_subscription_non_bars() {
        assert!(!is_bar_subscription("T.AAPL"));
        assert!(!is_bar_subscription("Q.AAPL"));
        assert!(!is_bar_subscription("LULD.AAPL"));
        assert!(!is_bar_subscription("FMV.AAPL"));
        assert!(!is_bar_subscription("*"));
        assert!(!is_bar_subscription("T.*"));
        assert!(!is_bar_subscription("Q.*"));
    }

    #[test]
    fn test_is_bar_subscription_edge_cases() {
        // Empty string
        assert!(!is_bar_subscription(""));

        // Just "A" or "AM" without dot
        assert!(!is_bar_subscription("A"));
        assert!(!is_bar_subscription("AM"));

        // Ms in symbol name (should still be considered bar)
        assert!(is_bar_subscription("100Ms.MSFT"));
    }
}